<!DOCTYPE HTML>
<html lang="zh-Hans">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="C/C++基础要点, AsilenceBTF&#39;s Blog">
    <meta name="description" content="人生当苦无妨,良人当归即好">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>C/C++基础要点 | AsilenceBTF&#39;s Blog</title>
    <link rel="icon" type="image/jpeg" href="/favicon2.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="AsilenceBTF's Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>



<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!--雪花特效-->
    
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/favicon2.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">AsilenceBTF&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/favicon2.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">AsilenceBTF&#39;s Blog</div>
        <div class="logo-desc">
            
            人生当苦无妨,良人当归即好
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/13.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">C/C++基础要点</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/C-C/">
                                <span class="chip bg-color">C/C++</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%9D%A2%E8%AF%95/" class="post-category">
                                面试
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-02-19
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    4.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    15 Min
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h4 id="C-C-程序基础"><a href="#C-C-程序基础" class="headerlink" title="C/C++程序基础"></a>C/C++程序基础</h4><ol>
<li><p>在<code>C++</code>中域操作符<code>::</code>可以直接操作全局变量,<code>C</code>中不支持域操作符, 编译时会报错</p>
</li>
<li><p>前缀式和后缀式效率(<code>++i</code>和<code>i++</code>)比较:</p>
<blockquote>
<p>当使用内建数据类型时,两个效率一样</p>
<p>当使用自定义数据类型时, 由于后缀式需要先用一个临时变量存储返回值,所以前缀式效率高</p>
</blockquote>
</li>
<li><p>码风良好的条件比较句</p>
<blockquote>
<p>当使用布尔变量时 使用<code>if(flag)</code>好于<code>if(flag == True)</code> 因为<code>True</code>固定为<code>1</code>, 但<code>flag</code>任何非<code>0</code>值都为真</p>
<p>当与<code>0</code>做比较时 使用<code>if(value != 0)</code> 好于<code>if(value)</code> 因为后者会误认为与布尔值做比较</p>
<p>浮点数作比较时,使用精度误差<code>eps</code>进行控制</p>
<p>指针变量与<code>0</code>比较时 <code>if(p==NULL)</code>好于<code>if(p==0)</code> 后者会让人误认为与0作比较</p>
</blockquote>
</li>
<li><p>无符号与有符号整数运算时, 都转化为无符号进行运算</p>
<p>且要注意溢出问题</p>
</li>
<li><p>不使用中间变量来交换<code>a,b</code>的值的方法</p>
<pre class="line-numbers language-c++"><code class="language-c++">void swap1(int &a, int &b){
    a = a + b;
    b = a - b;
    a = a - b;
    // 缺点是加减可能会在计算过程中溢出, 但不影响结果
}
void swap2(int &a, int &b){
    a ^= b;
    b ^= a;
    a ^= b;
    // 推荐用这种方式
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>C++与C有什么不同</strong></p>
<p><code>C</code>是结构化语言, 重点在于算法和数据结构. 对语言本身, <code>C</code>是<code>C++</code>的子集. <code>C</code>程序设计首先考虑如何通过一个过程,对输入进行运算处理,得到输出. 对于<code>C++</code>,首先要考虑如何构造一个对象模型,让这个模型能够配合对应的问题, 通过获取对象的状态信息得到输出或实现控制过程</p>
<p>因此,<code>C</code>和<code>C++</code>最大区别是解决问题的思想方法不一样</p>
<p><code>C</code>实现了<code>C++</code>中过程化控制及其他相关功能. 而在<code>C++</code>中的<code>C</code>, 相对于原来的<code>C</code>还有所加强, 引入了<strong>重载,内联函数,异常处理等</strong>. <code>C++</code>更是拓展了<strong>面向对象设计的内容, 如类,继承,虚函数,模板,包容器类等</strong></p>
<p>在<code>C++</code>中, 不仅需要考虑数据封装, 还需要考虑对象粒度的选择, 对象接口的设计和继承, 组合与继承的使用等问题</p>
<p>相对于<code>C,C++</code>包含了更丰富的设计概念</p>
</li>
<li><p>如何理解<code>C++</code>是面向对象化的, 而<code>C</code>是面向过程化的</p>
<p><code>C</code>是面向过程化的, 但<code>C++</code>不是完全面向对象化的. 在<code>C++</code>中也可以完全写出<code>C</code>一样过程化的程序, 所以<code>C++</code>只是拥有面向对象的特性. <code>Java</code>是真正面向对象化的</p>
</li>
<li><p>标准头文件的结构</p>
<pre class="line-numbers language-c++"><code class="language-c++">#ifndef __INCvxWorksh
#define __INCvxWorksh // 防止头文件被重复引用
#ifdef __cplusplus // 如果是c++文件
extern "C"{ // 模块按照C语言编译, 解决重载名字匹配问题
#endif
#ifdef __cplusplus
}
#endif
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>#include&lt;head.h&gt;</code> 与<code>"head.h"</code> 的区别</p>
<p>尖括号表明这个文件是一个工程或标准头文件, 会先从预定义的目录中查找</p>
<p>引号表明该文件是用户提供的头文件, 会先从当前文件目录寻找</p>
</li>
<li><p><code>C++</code>中<code>main</code>函数执行完后还执行其他语句吗?</p>
<p>可以使用<code>atexit</code>函数来注册函数在<code>main</code>函数结束后, 被<code>atexit</code>注册的函数会依次调用, 最先注册的最后调用, 最后注册的最先调用</p>
</li>
</ol>
<h4 id="预处理-const-static与sizeof"><a href="#预处理-const-static与sizeof" class="headerlink" title="预处理,const,static与sizeof"></a>预处理,const,static与sizeof</h4><ol>
<li><p>宏定义的注意事项</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define SQR(x) (x*x)
int main(){
    int a, b = 3;
    a = SQR(b + 2);
    printf("a = %d\n", a);  // 这里的输出是11
    //由于宏定义是在预处理时期,b没有被赋值,这时b只是一个符号,因此被展开成
    //a = (b + 2*b + 2); 执行后a被赋值为11
    /*为达到原来的目的可以将 SQR(x) 改成
        #define SQR(x) ((x) * (x))
    */
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>宏参数连接</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define STR(s) #s
#define CONS(a, b) (int)(a##e##b) // 连接(a,b)变成aeb
int main(){
    printf(STR(vck)); // 输出vck
    printf("\n");
    printf("%d\n", CONS(2, 3)); // 经过连接变成2e3, 输出2000
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>const</code> 的使用</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include<stdio.h>
int main(){
    const int x = 1; // 如果没有初始化就是随机数且不可变
    int b = 10;
    int c = 20;

    const int* a1 = &b; // const在int*左侧,修饰指针所指向的变量,即指针指向为常量
    int* const a2 = &b; // const在int*右侧,修饰指针本身,即指针为常量
    const int* const a3 = &b; // 指针为常量,指针指向也为常量
    x = 2; // 错误, x是常量不可变

    a1 = &c; // 指针可以改变
    *a1 = 1; // 错误, 指针指向的值为常量

    a2 = &c; // 错误,指针为常量
    *a2 = 1; // 指针指向的值可以改变

    a3 = &c; // 错误,指针为常量
    *a3 = 1; // 错误,指针指向的值为常量
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>说明<code>const</code>与<code>#define</code>的特点与区别</p>
<p><code>#define</code>只是用来做文本替换, 编译时进行替换,生命周期止于编译器,存在于程序的代码段, 实际过程只是一个常数,一个命令中的参数,没有实际存在.</p>
<p><code>const</code>常量存在程序的数据段, 并在堆栈分配了空间. <code>const</code>常量有数据类型,宏常量没有数据类型. 编译器可以对<code>const</code>常量进行类型安全检查</p>
</li>
<li><p><code>C++</code>中<code>const</code>有什么作用</p>
<ul>
<li><p><code>const</code>用于常量,<code>const</code>常量编译器可以对其进行数据类型安全检查</p>
</li>
<li><p>当输入参数<strong>用户自定义类型和抽象数据类型</strong>时, 应该将<code>值传递</code>改为<code>const&amp;传递</code>, 可以提高效率</p>
<pre class="line-numbers language-c++"><code class="language-c++">void fun(A a); 
//函数产生A类型的临时对象来复制参数a, 临时对象的构造,复制,析构过程都消耗时间.
void fun(A const &a); 
//使用引用传递不需要产生临时对象,提高效率.但光引用有可能改变a,所以加const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>const</code>修饰函数的返回值,如给<strong>指针传递</strong>的函数返回值加<code>const</code>,则返回值不能被直接修改,且返回值只能被赋值给加<code>const</code>修饰的同类型指针</p>
<pre class="line-numbers language-c++"><code class="language-c++">const char* Getchar(void){};
char* ch = Getchar(); // 错误
const char* ch = Getchar(); // 正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>const</code>修饰类的成员函数,任何不会修改数据成员的函数都应用<code>const</code>修饰, 这样,当不小心修改了数据成员或调用了非<code>const</code>成员函数时,编译器都会报错</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">GetCount</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><code>C++</code>中<code>static</code>有什么作用</p>
<ul>
<li>隐藏: 在模块内,一个被声明为静态的变量可以被模块内所有函数访问, 但不能被模块外其他函数访问, 相当于一个本地的全局变量</li>
<li>持久性: 变量会在程序刚开始运行时就完成初始化(<strong>全局变量也是</strong>),也是唯一的一次初始化</li>
<li>在模块内,一个被声明为静态的函数只可被这一模块的其他函数调用</li>
</ul>
</li>
<li><p>静态全局变量与普通全局变量有什么不同</p>
<p>非静态全局变量作用域是整个源程序,当一个源程序由多个源文件组成时,非静态的全局变量在各个源文件都是有效的</p>
<p>静态全局变量限制了作用域,即只在定义该变量的源文件内有效</p>
<p>static函数在内存中只有一份, 普通函数在每个被调用中维持一份复制品(<strong>static函数是可以递归的</strong>)</p>
</li>
<li><p><code>C++</code>类的静态成员</p>
<p>类的静态成员或方法不属于类的实例,在所有类的实例间共享, 调用时应用类名+操作符<code>::</code>来引用</p>
</li>
<li><p>使用<code>sizeof</code>计算普通变量所占空间</p>
<pre class="line-numbers language-c++"><code class="language-c++">// 32为WinNT操作系统下
char str[] = "Hello";
char *p = str;
int n = 10;
sizeof(str); // 6, 对数组变量sizeof计算得到数组占用内存大小,注意字符串还有结束符
sizeof(p);// 4, 指针类型32位为4字节
sizeof(n);// 4, int类型32位为4字节
void Func(char str[100]){
    sizeof(str); // 4, 由于数组作为参数是传址的, 所以也是4
}
void *p = malloc(100); //4,p指向一个100字节的堆内存
sizeof(p);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>使用<code>sizeof</code>计算类对象或<code>struct</code>所占空间</p>
<p>由于需要字节对齐,所以计算时总空间需要能够<strong>被其最宽基本类型成员的大小所整除</strong></p>
<p>所以需要填充字节</p>
</li>
<li><p>使用<code>sizeof</code>计算含有虚函数的类对象所占空间</p>
<p><strong>普通函数不占用内存</strong></p>
<p><strong>静态成员存储在静态存储区,不参与类大小的计算</strong></p>
<p>有虚函数的类还包括一个指针来维护这个类的虚函数表,所以<strong>多4个字节</strong></p>
</li>
<li><p>使用<code>sizeof</code>计算虚拟继承的类对象的空间大小</p>
<p><strong>如果是空类,编译器会自动安插一个char给空类,用来标记对象,  因此大小为1字节</strong></p>
<p>类普通继承, 大小不变</p>
<p>类虚继承, 编译器为该类安插一个指向父类的指针,大小为4. <strong>每多一个虚继承,大小都增加4</strong></p>
</li>
<li><p><code>sizeof</code>和<code>strlen</code>的区别</p>
<ul>
<li><code>sizeof</code>是操作符, <code>strlen</code>是函数</li>
<li><code>sizeof</code>操作符的结果类型是<code>size_t</code></li>
<li><code>sizeof</code>可以用类型做参数, <code>strlen</code>只用<code>char*</code>做参数, 且必须是以<code>"\0"</code>结尾的</li>
<li>数组做<code>sizeof</code>的参数不退化, 传递给<code>strlen</code>就退化成指针了</li>
<li>大部分编译程序在编译的时候<code>sizeof</code>就被计算过了, 这就是<code>sizeof(x)</code> 可以用来定义数组维数的原因. <code>strlen</code>的结果是要在运行的时候才能计算出来, 它用来计算字符串的长度,不是类型占内存的大小</li>
<li><code>sizeof</code>后如果是类型,必须加括弧; 如果是变量名,可以不加括弧. 因为<code>sizeof</code>是操作符,而不是函数</li>
<li>如果要计算指针指向的字符串的长度,则一定要用<code>strlen</code></li>
</ul>
</li>
<li><p><code>sizeof</code>的用途</p>
<ul>
<li>查看某个类型的对象在内存中所占的单元字节</li>
<li>分配内存时,可以让系统知道要分配多少内存</li>
<li>便于一些类型的扩充</li>
<li>计算指针大小</li>
</ul>
</li>
<li><p>内联函数<code>inline</code>的作用</p>
<p>代替<code>C</code>语言中的表达式形式的宏定义来解决程序中函数调用的效率问题</p>
<p>内联函数在使用时直接进行替换, 没有了调用的开销</p>
<p>类的内联函数也是一个真正的函数, 编译器会检查参数类型确保正确,消除了它的隐患和局限性</p>
</li>
<li><p><code>inline</code> 的使用场合</p>
<p><code>C++</code>类中对于私有或保护成员的接口函数写成内联函数,将会获得比较好的效率</p>
</li>
<li><p>为什么不把所有的函数都定义成内联函数?</p>
<p>内联函数是以代码膨胀为代价的, 仅省去了函数调用的开销, 从而提高函数的执行效率. </p>
<p>如果函数体内代码的时间相比于函数调用的开销较大, 那么总效率收获很少</p>
<p>另一方面,内联函数的调用都要复制代码,内存开销很大</p>
</li>
<li><p>内联函数和宏的区别</p>
<ul>
<li>内联函数在编译时展开, 宏在预编译是展开</li>
<li>在编译的时候,内联函数可以直接被镶嵌到目标代码, 宏只是一个简单的文本替换</li>
<li>内联函数可以完成类型检测,语句是否正确等编译功能, 宏不具有这样的功能</li>
<li>宏不是函数,<code>inline</code>函数是函数</li>
<li>宏定义是需要用括号括起来,否则容易出现二义性. 内联函数不会</li>
</ul>
</li>
</ol>
<h4 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h4><ol>
<li><p>引用的定义</p>
<p>对一个变量的引用就是它的别名, 他们在内存中存储的地址一样</p>
</li>
<li><p>引用的注意事项</p>
<p>引用必须初始化, 且只能在声明的时候赋值, 其他时刻不能作为其他变量的别名</p>
</li>
<li><p>指针和引用的区别</p>
<ul>
<li>引用创建时必须初始化; 指针不用初始化</li>
<li>引用初始化后不能修改绑定关系; 指针可以修改</li>
<li>不能引用<code>NULL</code>, 引用必须指向某个对象; 指针可以是<code>NULL</code>,所以更加灵活也更容易出错</li>
<li>引用不会指向空值,所以使用前不用测试合法性; 指针需要经常测试, 所以引用代码效率更高</li>
<li>语言层面引用的用法和指针一样, 底层引用还是用指针实现的</li>
</ul>
</li>
<li><p>为什么传引用比指针安全?</p>
<p>因为不存在空引用,  一旦引用被初始化就不能改变为另一个对象的引用</p>
<p>但是指针不用初始化,可以为空, 可以随时指向别的对象, 所以不安全</p>
</li>
<li><p>一些复杂指针的声明</p>
<pre class="line-numbers language-c++"><code class="language-c++">//一个整形数
int a;
//一个指向整型数的指针
int* a;
//一个指向指针的指针a, a指向的指针是指向一个整型数的
int** a;
//一个有10个整型数的数组
int a[10];
//一个有10个指针的数组,该数组的指针是指向一个整型数的
int* a[10];
//一个指向有10个整型数数组的指针
int (*a)[10];
//一个指向函数的指针, 该函数有一个整型参数并返回一个整型数
int (*a)(int);
//一个有10个指针的数组,该指针指向一个函数,该函数有一个整型参数并返回一个整型数
int (*a[10])(int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>指针常量与常量指针的区别</p>
<pre class="line-numbers language-c++"><code class="language-c++">//指针常量 该指针指向整型且不可改变
int* const a;
//常量指针 该指针指向一个常量,指针可以改变,指向的值不可以
const int* a;
int const* a;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>指针函数和函数指针的区别</p>
<pre class="line-numbers language-c++"><code class="language-c++">//指针函数 指一个返回值是指针的函数
int* f(int a, int b){

}
int max(int x, int y){}
//函数指针 指一个指针指向的是一个函数
int (*p)(int, int) = max;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>什么是<code>野指针</code>?</p>
<p><code>野指针</code>不是<code>NULL</code>指针, 而是指向<code>"垃圾"</code>内存的指针. <code>野指针</code>一旦出现很难判断</p>
<p>成因主要有两种:</p>
<ul>
<li>指针变量没有被初始化, 指针指向随机, 所以指针建立时应当初始化</li>
<li>指针<code>p</code>被<code>free</code>或者<code>delete</code>之后,没有置<code>NULL</code>, 让人误以为<code>p</code>是个合法指针</li>
</ul>
<p><code>野指针</code>指向的指是随机的,所以可能使得程序崩溃</p>
</li>
<li><p>有<code>malloc/free</code>, 为什么还要<code>new/delete</code> ? </p>
<p>对于非内建数据,<code>malloc/free</code>无法满足动态对象的要求. 对象要求创建的同时要自动执行构造函数, 对象在消亡前要自动执行构析函数. <code>malloc/free</code>是库函数不是运算符,不在编译权限内,不能执行构造函数和析构函数</p>
<p>因此只有使用<code>new/delete</code></p>
</li>
<li><p>内存的分配方式有几种?</p>
<ul>
<li>静态存储区. 在程序编译时就已经分配好,例如全局变量或者<code>static</code>变量</li>
<li>在栈上创建. 执行函数时,函数内局部变量的存储单元都可以在栈上创建,函数结束时自动释放,效率高,但是分配容量有限</li>
<li>在堆上分配,也叫动态内存分配. 程序运行时用<code>malloc</code>或<code>new</code>申请内存,程序员自己复杂何时用<code>free</code>或<code>delete</code>释放内存, 动态内存生存期有我们决定,非常灵活</li>
</ul>
</li>
</ol>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ol>
<li><p>编程实现<code>strcpy</code>函数</p>
<pre class="line-numbers language-c++"><code class="language-c++">char* strcpy(char* strDest, char* strSrc){
    if((strDest == NULL) || (strSrc == NULL)){
        return NULL;
    } // 特判不合法
    char* strDestCopy = strDest;
    while((*strDest++ = *strSrc++) != '\0');
    return strDestCopy;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>编程实现<code>memcpy</code>函数</p>
<pre class="line-numbers language-c++"><code class="language-c++">void* memcpy2(void* memTo, const void* memFrom, size_t size){
    assert((memTo != NULL) && (memFrom != NULL)); // 判断合法性
    char* tempFrom = (char*) memFrom;
    char* tempTo = (char*) memTo;
    while(size-- > 0){
        *tempTo++ = *tempFrom++;
    }
    return memTo;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>strcpy</code>和<code>memcpy</code>的区别</p>
<ul>
<li><code>strcpy</code>只能复制字符串, <code>memcpy</code>可以复制任意内容, 例如字符数组,整型,,结构体,类等</li>
<li>复制的方法不同. <code>strcpy</code>不需要指定长度,他是遇到<code>'\0'</code>而结束的, <code>memcpy</code>根据第三个参数决定复制的长度</li>
<li>用途不同,字符串用<code>strcpy</code>,其他用<code>memcpy</code></li>
</ul>
</li>
</ol>
<h4 id="位运算与嵌入式编程"><a href="#位运算与嵌入式编程" class="headerlink" title="位运算与嵌入式编程"></a>位运算与嵌入式编程</h4><ol>
<li><p>设置或清楚特定的位</p>
<pre class="line-numbers language-c++"><code class="language-c++">//清楚或设置整型的bit3
#define BIT3 (0x1 << 3)
void set_bit3_1(int &a){ // 置1
    a |= BIT3; 
}
void set_bit3_0(int &a){ // 置0
    a &= ~BIT3;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>隐式类型转换</p>
<ul>
<li><p>算术转换：在混合类型的算术表达式种, 最宽的数据类型成为目标转换类型</p>
</li>
<li><p>一种类型表达式赋值给另一种类型的对象: 目标类型是被赋值对象的类型</p>
<p><strong>void指针赋值给其他类型指针时,无法转换, 编译出错</strong></p>
</li>
<li><p>将一个表达式作为实参传递给函数调用, 此时形参和实参类型不一致: 目标转换类型为形参的类型</p>
</li>
<li><p>从一个函数返回一个表达式,表达式类型与返回类型不一致: 目标转换类型为函数的返回类型</p>
</li>
</ul>
</li>
<li><p>显示类型转换: 列举并解释<code>C++</code>中的4种运算符转化以及他们的不同点</p>
<ul>
<li><p><code>const_cast</code>操作符:  用来修改类型的<code>const</code>或<code>volatile</code>属性</p>
<pre class="line-numbers language-c++"><code class="language-c++">const int constant = 21;
const int* const_p = &constant; // 常量指针
int* modifier = const_cast<int*>(const_p); // 将常量指针转化为普通指针
*modifier = 7; //成功修改constant的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>dynamic_cast</code>操作符:  转换类型必须是类的指针,类的引用或者<code>void*</code></p>
<p>适用于当无法使用<code>virtual</code>函数的时候</p>
</li>
<li><p><code>static_cast</code>该类型把<code>expression</code>转换成<code>type-id</code>, 但没有运行时类型检查来保证转换的安全性</p>
<p>为什么需要<code>static_cast</code>?</p>
<p>情况1: <code>void</code>指针转换为其他类型指针</p>
<p>情况2:改变通常的标准转换</p>
<p>情况3:避免出现可能多种转换的歧义</p>
</li>
<li><p><code>reinpreter_cast</code>操作符: <code>type-id</code>必须是一个指针,引用,算术类型,函数指针或者成员指针. 可以把一个指针转换成一个整数,也可以把一个整数转换成一个指针(先把一个指针转换成一个整数, 在把该整数转换成原类型的指针,还可以得到原先的指针值)</p>
</li>
</ul>
</li>
<li><p>如何写死循环? (这我可是一把好手0.0)</p>
<pre class="line-numbers language-c++"><code class="language-c++">//
while(1) {}
//
for(;;){}
//
Loop:
...
goto Loop;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>关键字<code>volatile</code>有什么作用?</p>
<p>一个定义为<code>volatile</code>的变量可能会被意想不到的改变,这样,编译器就不会去假设这个变量的值了. 准确的说,就是优化器在用到这个变量时必须每次都小心的重新读取这个变量的值,而不是使用保存在寄存器里的备份</p>
<ul>
<li>并行设备的硬件寄存器(如状态寄存器)</li>
<li>一个中断服务子程序中会访问到的非自动变量</li>
<li>多线程应用中被几个任务共享的变量</li>
</ul>
</li>
</ol>
<h4 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h4><ol>
<li><p>面向对象的概念</p>
<p>面向对象是按照人们认识客观世界的系统思维方式, 采用基于对象(实体)的概念建立模型,模拟客观世界分析,设计,实现软件的办法, 包括类,对象,消息以及类的特性等方面的内容</p>
</li>
<li><p><code>class</code>和<code>struct</code>有什么区别?</p>
<p>这里的区别分两种情况: <code>C</code>语言的<code>struct</code>和<code>C++</code>的<code>class</code>的区别, <code>C++</code>中的<code>struct和class</code>的区别</p>
<ul>
<li><p><code>C</code>中的<code>struct</code>只能定义成员变量, 不能定义成员函数</p>
</li>
<li><p>在<code>C++</code>中的<code>struct</code>扩充了<code>C</code>的<code>struct</code>功能, 拥有构造函数和成员函数,还拥有<code>class</code>的其他特性, 如继承,虚函数等.</p>
<p><code>struct</code>中默认成员访问权限是<code>public</code>的, 默认继承是<code>public</code>继承, 不能表示模板类型</p>
<p><code>class</code>中默认成员访问权限是<code>private</code>的, 默认继承是<code>private</code>继承, 可以表示模板类型</p>
</li>
</ul>
</li>
<li><p>类成员的初始化</p>
<p>初始化时与声明先后顺序一致</p>
</li>
<li><p>与全局对象相比, 使用静态数据成员有什么优势?</p>
<ul>
<li>静态数据成员不会和其他全局命名冲突</li>
<li>使用静态数据成员可以使用<code>private</code>隐藏信息, 全局对象不能</li>
</ul>
</li>
<li><p>哪种情况只能用<code>intialization list</code>(初始化表), 而不能用<code>assignment</code>(赋值)?</p>
<p>对于类中有<code>const</code>和<code>reference</code>(引用)类型成员变量, 只能够用初始化列表, 不能赋值</p>
<p>还有一种情况, 类的构造函数需要调用其基类的构造函数的时候</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>
using namespace std;
class A{
private:
    int a;
public:
    A(){}
    A(int x) : a(x) {}
};
class B : public A {// B是A的子类, 以public方式继承
private:
    int b;
public:
    B(int x, int y) : A(x){ // 需要初始化b, 以及父类的a
        // a =x; // 错误, a为private, 无法在子类访问
        // A(x); // 错误, 调用方式错误
        b = y;
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>C++</code>中的空类默认会产生哪些成员函数?</p>
<p><code>C++</code>的空类中, 默认会产生默认构造函数, 复制构造函数, 析构函数, 赋值函数以及取址运算</p>
</li>
<li><p>构造函数和析构函数是否可以被重载?</p>
<p>构造函数可以被重载, 因为构造函数可以有多个, 且可以带参数</p>
<p>析构函数不可以被重载, 因为析构函数只能有一个, 且不能带参数</p>
</li>
<li><p><code>C++</code>中虚析构函数的作用是什么?</p>
<p>当父类指针指向子类对象时, 释放指针时, 只会执行父类的析构函数, 子类的内存得不到释放</p>
<p>将父类的析构函数加上<code>virtual</code>, 就会先找到并执行子类的析构函数, 然后执行父类的析构函数,资源正常释放, 避免了内存泄漏</p>
<p>因此, <strong>只有当一个类被用来作为基类的时候, 才会把析构函数写成虚函数</strong></p>
</li>
<li><p>析构函数的执行顺序</p>
<p>析构函数的执行顺序与构造函数的执行顺序相反</p>
<p>谁先声明, 谁后析构</p>
<p>先析构子类,再析构父类</p>
</li>
<li><p>什么是复制构造函数?</p>
<p>如果类中没有显示声明一个复制构造函数,那么编译器会制定一个函数来进行对象的复制</p>
<p>以下三种需要复制构造函数的情况</p>
<ul>
<li>一个对象以值传递的方式传入函数体</li>
<li>一个对象以值传递的方式从函数返回</li>
<li>一个对象需要通过另外一个对象进行初始化</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">class Test{
public:
    int a;
    Test(int x) : a(x) {}
    Test(Test &test){ // 复制构造函数
        a = test.a;
    }
}
void fun1(Test test){} // 值传递传入函数体
Test fun2() { Test test; return test; } // 值传递从函数体返回
int main(){
    Test t1(1);
    Test t2 = t1; // 用t1对t2做初始化
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>为什么<code>C</code>语言不支持函数重载而<code>C++</code>能支持?</p>
<p><code>C++</code>的重载函数经过编译器处理之后, 两个函数的符号是不相同的. 这样的名字包含了函数名,函数参数,以及返回类型信息</p>
<p><code>C</code>语言不会对函数名进行处理</p>
</li>
<li><p>重载和覆写有什么区别?</p>
<p>重载是编写一个已有函数同名但是参数表不同的方法, 有如下特征</p>
<ul>
<li>方法名必须相同</li>
<li>参数列表必须不相同, 与参数列表的顺序无关</li>
<li>返回值类型可以不相同</li>
</ul>
<p>覆写是派生类重写基类的虚函数, 有如下特征</p>
<ul>
<li>只有虚方法和抽象方法才能够被覆写</li>
<li>相同的函数名</li>
<li>相同的参数列表</li>
<li>相同的返回值类型</li>
</ul>
<p>重载是一种语法规则, 由编译器在编译阶段完成, 不属于面向对象</p>
<p>覆写是运行阶段决定的, 是面向对象编程的重要特征</p>
</li>
</ol>
<h4 id="C-继承和多态"><a href="#C-继承和多态" class="headerlink" title="C++继承和多态"></a>C++继承和多态</h4><ol>
<li><p>继承的三种关系: <code>public,protected,private</code></p>
<p>无论是哪种继承方式,基类的<code>private</code>成员总是无法从子类访问</p>
<p>无论是哪种继承方式, 在<strong>派生类内部</strong>总是可以访问基类的<code>public,protected</code>成员</p>
<p>仅当<code>public</code>派生时, <strong>派生类对象</strong>对基类中的<code>public</code>成员有可访问/可修改权</p>
<ul>
<li><code>public</code> 继承不改变基类成员的访问权限</li>
<li><code>protected</code>继承将基类中<code>public</code>成员变为子类的<code>protected</code>成员, 其他成员的访问权限不变</li>
<li><code>private</code>使得基类中所有成员在子类中权限变成<code>private</code></li>
</ul>
</li>
<li><p><code>C++</code>为什么定义<code>public,protected,private</code>三种权限?</p>
<p>有些我们需要对外面看的,也就是对外接口,那么就使用<code>public</code>. 如果我们不想让别人知道内部的实现细节,那么就是<code>private</code>. 如果不想让别人知道, 想让自己的孩子知道, 那么就可以作为<code>protected</code></p>
</li>
<li><p>什么是多态?</p>
<ul>
<li>编译时的多态: 通过重载来实现</li>
<li>运行时的多态: 通过虚成员来实现</li>
</ul>
</li>
<li><p>为什么需要多继承? 它的优缺点是什么?</p>
<p>一些事物往往会拥有两个或多个以上事物的属性, 为了解决这个问题,<code>C++</code>引入多重继承的概念</p>
<p>多重继承的优点是对象可以调用多个基类中的接口</p>
<p>多重继承的缺点是容易出现继承向上的二义性</p>
</li>
<li><p>如何消除二义性?</p>
<p>使用虚继承</p>
</li>
<li><p>为什么要引入抽象基类和纯虚函数?</p>
<p><strong>纯虚函数</strong>在基类中是没有定义的, 必须在子类中加以实现</p>
<p>如果基类含有一个或多个纯虚函数,那么就属于<strong>抽象基类</strong></p>
<ul>
<li>为了方便使用多态特性</li>
<li>很多情况下,基类本身生成对象不合理. 例如,动物作为一个基类可以派生老虎,狮子, 但动物本身生成对象不合理,抽象对象不能被实例化,它定义的纯虚函数相当于接口</li>
</ul>
</li>
<li><p>虚函数和纯虚函数有什么区别?</p>
<ul>
<li><p>类里如果声明了虚函数,这个函数是实现的(哪怕是空实现),它的作用就是为了能让这个函数在它的子类里面可以被覆盖,从而实现多态. 纯虚函数只是一个接口,一个声明,要留到子类才能实现</p>
</li>
<li><p>虚函数在子类可以不重载; 但纯虚函数必须在子类去实现</p>
</li>
<li><p>虚函数的类用于<code>"实作继承"</code>, 也就是说继承接口的同时也继承了父亲的实现</p>
<p>纯虚函数的类用于<code>"介面继承"</code>,即纯虚函数关注的是接口的统一性,实现由子类完成</p>
</li>
<li><p>带纯虚数的类叫做抽象基类, 只有被继承,重写虚函数后才能使用</p>
</li>
</ul>
</li>
<li><p>什么是<code>COM</code>?</p>
<p><code>COM</code>即组件对象模型, 它定义了一种二进制标准,使得任何编程语言存取它所编写的模块</p>
</li>
</ol>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol>
<li><p>插入排序</p>
<pre class="line-numbers language-c++"><code class="language-c++">
void print(int* a, int n){
    for(int i = 0; i < n; ++i){
        cout << a[i] << " ";
    }
    cout << endl;
}
void insert_sort(int* a, int n){
    for(int i = 1; i < n; ++i){
        int temp = a[i];
        int idx = i - 1;
        while(idx >= 0 && a[idx] > temp) {
            a[idx + 1] = a[idx];
            --idx;
        }
        a[idx + 1] = temp;
    }
}
int main(){
    int a[] = {3, 4, 2, 6, 5, 7};
    cout << "before insert sort: ";
    print(a, 6);
    insert_sort(a, 6);
    cout << "after insert sort: ";
    print(a, 6);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>希尔排序</p>
<pre class="line-numbers language-c++"><code class="language-c++">
void print(int* a, int n){
    for(int i = 0; i < n; ++i){
        cout << a[i] << " ";
    }
    cout << endl;
}
void shell_sort(int* a, int n){
    for(int i = n / 2; i > 0; i /= 2){
        for(int j = i; j < n; ++j){
            int idx = j - i, temp = a[j];
            while(idx >= 0 && a[idx] > temp){
                a[idx + i] = a[idx];
                idx -= i;
            }
            a[idx + i] = temp;
        }
    }
}
int main(){
    int a[] = {4, 3, 5, 1, 6, 2};
    int n = 6;
    cout << "before shell_sort :";
    print(a, n);
    cout << "afters shell_sort :";
    shell_sort(a, n);
    print(a, n);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>冒泡排序</p>
<pre class="line-numbers language-c++"><code class="language-c++">
void print(int* a, int n){
    for(int i = 0; i < n; ++i){
        cout << a[i] << " ";
    }
    cout << endl;
}
void bubble_sort(int* a, int n){
    for(int i = 0; i < n; ++i){
        int change = 0;
        for(int j = n - 2; j >= i; --j){
            if(a[j + 1] < a[j]){
                a[j + 1] ^= a[j];
                a[j] ^= a[j + 1];
                a[j + 1] ^= a[j];
                change = 1;
            }
        }
        if(!change) return;
    }
}
int main(){
    int a[] = {4, 3, 6, 5, 2, 1};
    int n = 6;
    cout << "before bubble_sort : ";
    print(a, n);
    bubble_sort(a, n);
    cout << "after bubble_sort : ";
    print(a, n);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>快速排序</p>
<pre class="line-numbers language-c++"><code class="language-c++">
void print(int *a, int n){
    for(int i = 0; i < n; ++i){
        cout << a[i] << " ";
    }
    cout << endl;
}
void quick_sort(int *a, int l, int r){
    if(l >= r) return;
    int key = a[l];
    int i = l, j = r;
    while(i < j){
        while(i < j && a[j] >= key) --j;
        if(i < j)
            a[i++] = a[j];
        while(i < j && a[i] <= key) ++i;
        if(i < j)
            a[j--] = a[i];
    }
    a[i] = key;
    quick_sort(a, l, i - 1);
    quick_sort(a, i + 1, r);
}
int main(){

    int a[] = {4, 3, 6, 5, 2, 1};
    int n = 6;
    cout << "before quick_sort : ";
    print(a, n);
    quick_sort(a, 0, n - 1);
    cout << "after quick_sort : ";
    print(a, n);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>选择排序</p>
<pre class="line-numbers language-c++"><code class="language-c++">
void print(int *a, int n){
    for(int i = 0; i < n; ++i){
        cout << a[i] << " ";
    }
    cout << endl;
}
void select_sort(int *a, int n){
    for(int i = 0; i < n - 1; ++i){
        int idx = i;
        for(int j = i + 1; j < n; ++j){
            if(a[j] < a[idx]){
                idx = j;
            }
        }
        if(idx != i){
            a[idx] ^= a[i];
            a[i] ^= a[idx];
            a[idx] ^= a[i];
        }
    }
}
int main(){
    int a[] = {4, 3, 6, 5, 2, 1};
    int n = 6;
    cout << "before select_sort : ";
    print(a, n);
    select_sort(a, n);
    cout << "after select_sort : ";
    print(a, n);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>归并排序</p>
<pre class="line-numbers language-c++"><code class="language-c++">
void swap(int *a, int *b){
    *a ^= *b;
    *b ^= *a;
    *a ^= *b;
}
void print(int *a, int n){
    for(int i = 0; i < n; ++i){
        cout << a[i] << " ";
    }
    cout << endl;
}
void Merge(int *a, int *b, int l, int r){
    int lend = l + r >> 1;
    int rend = r;
    int lpos = l, rpos = lend + 1, idx = 0;
    while(lpos <= lend && rpos <= rend){
        if(a[lpos] <= a[rpos])
            b[idx++] = a[lpos++];
        else
            b[idx++] = a[rpos++];
    }
    while(lpos <= lend)
        b[idx++] = a[lpos++];
    while(rpos <= rend)
        b[idx++] = a[rpos++];
    for(int i = l, j = 0; i <= r; ++i){
        a[i] = b[j++];
    }
}
void merge_sort(int *a, int *b, int l, int r){
    if(l >= r) return;
    int mid = l + r >> 1;
    merge_sort(a, b, l, mid);
    merge_sort(a, b, mid + 1, r);
    Merge(a, b, l, r);
}
int main(){
    int a[] = {4, 3, 6, 5, 2, 1};
    int n = 6;
    cout << "before merge_sort : ";
    print(a, n);
    int *b = NULL;
    b = new int[n];
    merge_sort(a, b, 0, n - 1);
    delete []b;
    cout << "after merge_sort : ";
    print(a, n);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h4 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h4><ol>
<li><p>函数模板和类模板</p>
<pre class="line-numbers language-c++"><code class="language-c++">
template <class T1, class T2>
class Point_T{
public:
        T1 a; T2 b;
        Point_T() : a(0), b(0){}
        Point_T(T1 x, T2 y) : a(x), b(y) {}
        Point_T<T1, T2> operator = (const Point_T<T1, T2> &pt); // 重载赋值 函数
        Point_T<T1, T2> operator + (const Point_T<T1, T2> &pt); //重载+
};

template <class T1, class T2>
Point_T<T1, T2> Point_T<T1, T2> :: operator=(const Point_T<T1, T2> &pt){
        this->a = pt.a;
        this->b = pt.b;
        return *this;
}
template <class T1, class T2>
Point_T<T1, T2> Point_T<T1, T2> :: operator+(const Point_T<T1, T2> &pt){
        return Point_T(a + pt.a, b + pt.b);
}
template <class T1, class T2>
ostream& operator << (ostream& out,const Point_T<T1, T2> &pt){
        cout << "(" << pt.a << ", ";
        cout << pt.b << ")";
        return out;
}
int main(){
        Point_T<int,int> intPt1(1, 2);
        Point_T<int,int> intPt2(1, 2);
        Point_T<float,float> floatPt1(1.0, 2.0);
        Point_T<float,float> floatPt2(1.0, 2.0);

        Point_T<int, int> inttol;
        Point_T<float, float> floattol;
        inttol = intPt1 + intPt2;
        floattol = floatPt1 + floatPt2;
        //cout << inttol << endl;
        //cout << floattol << endl;
        cout << "intPt1 = " << intPt1 << ", intPt2 = " << intPt2 << endl;
        cout << "inttol = " << intPt1 + intPt2 << endl;
        cout << "floatPt1 = " << floatPt1 << ", floatPt2 = " << floatPt2 << endl;
        cout << "floattol = " << floattol << endl;
        return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数模板是一种抽象的函数定义, 他代表一类同构函数. 类模板是一种更高层次的抽象的类定义</p>
<p>函数模板的实例化在编译阶段完成, 而类模板的实例化需由程序员在程序中指定</p>
</li>
<li><p>使用模板有什么缺点? 如何避免</p>
<p>不正当的使用模板会导致代码膨胀, 影响程序的运行效率</p>
<p>解决办法: 把<code>C++</code>模板中与参数无关的代码分离出来</p>
</li>
</ol>
<h4 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h4><ul>
<li><code>STL</code>序列容器: <code>vector, string, deque, list</code></li>
<li><code>STL</code>关联容器: <code>set, multiset, map, multimap</code></li>
<li><code>STL</code>适配容器: <code>stack, queue, priority_queue</code></li>
</ul>
<ol>
<li><p>概念</p>
<p><code>STL</code>,即标准模板库 , 是一个高效的<code>C++</code>程序库, 它是最新的<code>C++</code>标准函数库中的一个子集, 包括容器,算法, 迭代器组件</p>
</li>
<li><p><code>STL</code>如何实现<code>vector</code></p>
<p><code>vector</code>内部是使用动态数组的方式实现的. 如果动态数组的内存不够, 就申请内存, 一般</p>
<p>是当前大小的两倍, 然后把原数组的内容拷贝过去. 申请内存是<code>1-&gt;2-&gt;4-&gt;8...</code></p>
</li>
<li><p><code>map</code>内部是怎么实现的?</p>
<p>底层是红黑树</p>
</li>
<li><p><code>map</code>和<code>hashmap</code>有什么区别?</p>
<ul>
<li><code>map</code>是红黑树, <code>hashmap</code>是哈希表</li>
<li><code>map</code>可以自动按照键值排序, <code>hashmap</code>的各项操作平均时间复杂度接近常数</li>
<li><code>map</code>是标准的一部分, 而<code>hashmap</code>不是</li>
</ul>
</li>
<li><p><code>vector</code>中的<code>erase</code>和<code>algorithm</code>中的<code>remove</code>有什么区别?</p>
<ul>
<li><code>vector</code>中<code>erase</code>是真正删除了元素,迭代器不能访问了</li>
<li><code>algorithm</code>中的<code>remove</code>只是简单的把要删除的元素移到了容器最后面, 迭代器还是可以访问的, 因为<code>algorithm</code>通过迭代器操作, 不知道容器的内部结构, 所以无法做到真正的删除</li>
</ul>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">AsilenceBTF</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://www.asilencebtf.top/2021/021935383.html">http://www.asilencebtf.top/2021/021935383.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">AsilenceBTF</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/C-C/">
                                    <span class="chip bg-color">C/C++</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'c5d1e87a412f96013a97',
        clientSecret: '565e7ca980f31802b3096cdc5c42f5b598c13ea3',
        repo: 'AsilenceBTF.github.io',
        owner: 'AsilenceBTF',
        admin: "AsilenceBTF",
        id: '2021-02-19T16-35-08',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;Current
            </div>
            <div class="card">
                <a href="/2021/021935383.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="C/C++基础要点">
                        
                        <span class="card-title">C/C++基础要点</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            C/C++基础要点,面试必备
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-02-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%9D%A2%E8%AF%95/" class="post-category">
                                    面试
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C-C/">
                        <span class="chip bg-color">C/C++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/102035032.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="2020CCPC秦皇岛云打星">
                        
                        <span class="card-title">2020CCPC秦皇岛云打星</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            2020CCPC秦皇岛云打星
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-10-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/CCPC/" class="post-category">
                                    CCPC
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%80%9D%E7%BB%B4/">
                        <span class="chip bg-color">思维</span>
                    </a>
                    
                    <a href="/tags/dp/">
                        <span class="chip bg-color">dp</span>
                    </a>
                    
                    <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/">
                        <span class="chip bg-color">双指针</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>


    
    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="5035831886"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">AsilenceBTF</a>
            <!-- |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> -->
            <!-- |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a> -->
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                &nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/AsilenceBTF" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:951208871@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=951208871" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 951208871" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);  // 50ms周期检测函数
        var pvcountOffset = 80000;  // 初始化首次数据
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    });
</script>

    
    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>
    
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
        <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    
    
    
    
    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

    <script type="text/javascript"> var OriginTitile = document.title, st; 
    document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ桥豆麻袋", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪偶盖利纳塞！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) }) </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
        
</body>

</html>
