<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces 658(div2)</title>
    <url>/2020/07231255.html</url>
    <content><![CDATA[<h4 id="A-Common-Subsequence"><a href="#A-Common-Subsequence" class="headerlink" title="A  Common Subsequence"></a>A  Common Subsequence</h4><p>签到</p>
<pre class="line-numbers language-c++"><code class="language-c++">
#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 5e5 + 105;

void solve(){
    int n, m;
    cin >> n >> m;
    set<int>se;
    for(int i = 1; i <= n; ++i){
        int x; cin >> x;
        se.insert(x);
    }
    int k = 0, flag = 0;
    for(int i = 1; i <= m; ++i){
        int x;
        cin >> x;
        if(se.count(x) > 0){
            k = 1; flag = x;
        }
    }
    if(k){
        cout << "YES" << endl;
        cout << k << " " << flag << endl;
    }else{
        cout << "NO" << endl;
    }
}
int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="B-Sequential-Nim"><a href="#B-Sequential-Nim" class="headerlink" title="B  Sequential Nim"></a>B  Sequential Nim</h4><blockquote>
<p>结论: 首先碰到 &gt; 1 的数的人胜利</p>
</blockquote>
<p>证明的话只要分三种情况</p>
<blockquote>
<ol>
<li><p>序列为3 3 3 3</p>
<p>轮流拿 2 1 2 1 2 1 3</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><p>序列为3 1 3 3</p>
<p>轮流拿 3 1 2 1 3</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><p>序列为 3 1 1 3</p>
<p>轮流拿 2 1 1 1 3</p>
</li>
</ol>
</blockquote>
<p>以上三种序列足以覆盖所有情况</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 1e5 + 105;
int a[N];
void solve(){
    int n;
    cin >> n;
    int one = 0, idx = 0;
    for(int i = 1; i <= n; ++i){
        cin >> a[i];
        if(a[i] == 1) one++;
        else{
            if(idx == 0) idx = i;
        }
    }
    if(one == 0){
        cout << "First" << endl; return;
    }else if(one == n){
        if(n&1) cout << "First" << endl;
        else cout << "Second" << endl;
    }else{
        if(idx&1) cout << "First" << endl;
        else cout << "Second" << endl;
    }

}
int main(){c++
    cin.tie(0);
    ios::sync_with_stdio(0);
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="C-Prefix-Flip"><a href="#C-Prefix-Flip" class="headerlink" title="C  Prefix Flip"></a>C  Prefix Flip</h4><p>若串首字符不等于目标字符, 则直接翻转</p>
<p>若串首字符等于目标字符, 则先翻转串首, 在翻转</p>
<p>这样构造一定小于$2n$</p>
<p>双指针记录一下串首和串尾的位置和翻转情况即可</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 1e5 + 105;
void solve(){
    int n, l, r, f = 0; cin >> n;
    string s, t;
    cin >> s >> t;
    if(s == t){
        cout<<0<<endl; return;
    }
    l = 0, r = n - 1;
    vector<int> ans;
    for(int i = n - 1; i >= 0; --i){
        if((s[l] == t[i] && f%2 == 0) || (s[l] != t[i] && f%2 == 1)){
            ans.push_back(1);
        }
        ans.push_back(i + 1);
        f++;
        swap(l, r);
        if(f&1) ++r;
        else --r;
    }
    cout<<sz(ans)<<" ";
    for(auto it : ans) cout<<it<<" ";
    cout<<endl;
}
int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="D-Unmerge"><a href="#D-Unmerge" class="headerlink" title="D  Unmerge"></a>D  Unmerge</h4><p>01背包变形</p>
<p>观察发现, 两个前缀最大之间的数是可以连续的存在一个序列里的</p>
<p>预处理出所有这样的段</p>
<p>dp一下能不能组成长度为n的序列即可</p>
<pre class="line-numbers language-c++"><code class="language-c++">
#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 4050;
int a[N], pre[N], preidx[N], dp[N];
void solve(){
    int n; cin >> n;
    int m = n + n;
    for(int i = 1; i <= m; ++i){
        cin >> a[i];
        pre[i] = a[i];
        preidx[i] = i;
        if(pre[i - 1] > pre[i]){
            pre[i] = pre[i - 1];
            preidx[i] = preidx[i - 1];
        } dp[i] = 0;
    }
    vector<int> v;
    for(int i = 2; i <= m; ++i){
        if(preidx[i] == i){
            v.push_back(preidx[i] - preidx[i - 1]); 
        }
    }
    for(auto it : v){
        for(int j = n; j >= it; --j){
            dp[j] = max(dp[j], dp[j - it] + it);
        }
    }
    if(dp[n] == n) cout << "YES" << endl;
    else cout << "NO" << endl;
}
int main(){
    int  _ = 1;
    cin >> _;c++
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>dream deverse</title>
    <url>/2020/072338086.html</url>
    <content><![CDATA[<blockquote>
<p>这是一个测试页面</p>
</blockquote>
<pre class="line-numbers language-c++"><code class="language-c++">
#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
#define LNF 0x3f3f3f3f3f3f3f3f
#define DOF 0x7f7f7f7f
typedef long long ll;
const int N = 2e5 + 105;
struct KM
{
    vector<vector<ll>> edge;
    vector<int> pa;
    vector<int> pb;
    vector<bool> visx;
    vector<bool> visy;
    vector<int> pre;
    vector<ll> lx;
    vector<ll> ly;
    vector<ll> slack;
    ll res = 0, inf;
    int n, _n, _m;
    queue<int> que;
    KM(int __n, int __m) : _n(__n), _m(__m)
    {
        res = 0;
        inf = LNF;
        n = max(_n, _m);
        edge = vector<vector<ll>>(n + 1, vector<ll>(n + 1));
        pa = vector<int>(n + 1);
        pb = vector<int>(n + 1);
        visx = vector<bool>(n + 1);
        visy = vector<bool>(n + 1);
        pre = vector<int>(n + 1);
        lx = vector<ll>(n + 1, -inf);
        ly = vector<ll>(n + 1);
        slack = vector<ll>(n + 1);
    }
    void add(int u, int v, ll w)
    {
        edge[u][v] = max(0ll, w);
    }
    bool check(int v)
    {
        visy[v] = true;
        if (pb[v])
        {
            que.push(pb[v]);
            visx[pb[v]] = true;
            return false;
        }
        while (v)
        {
            pb[v] = pre[v];
            swap(v, pa[pre[v]]);
        }
        return true;
    }
    void bfs(int u)
    {
        while (!que.empty())
            que.pop();
        visx[u] = true;
        que.push(u);
        while (true)
        {
            while (!que.empty())
            {
                u = que.front();
                que.pop();
                for (int v = 1; v <= n; ++v)
                {
                    if (!visy[v])
                    {
                        ll delta = lx[u] + ly[v] - edge[u][v];
                        if (slack[v] >= delta)
                        {
                            pre[v] = u;
                            if (delta)
                            {
                                slack[v] = delta;
                            }
                            else if (check(v))
                            {
                                return;
                            }
                        }
                    }
                }
            }
            ll a = inf;
            for (int i = 1; i <= n; ++i)
            {
                if (!visy[i])
                {
                    a = min(a, slack[i]);
                }
            }
            for (int i = 1; i <= n; ++i)
            {
                if (visx[i])
                {
                    lx[i] -= a;
                }
                if (visy[i])
                {
                    ly[i] += a;
                }
                else
                {
                    slack[i] -= a;
                }
            }
            for (int i = 1; i <= n; ++i)
            {
                if (!visy[i] && slack[i] == 0 && check(i))
                {
                    return;
                }
            }
        }
    }
    void solve()
    {
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                lx[i] = max(lx[i], edge[i][j]);
            }
        }
        // for(int i = 1; i <= n; ++i) cout << lx[i] << " ";
        for (int i = 1; i <= n; ++i)
        {
            fill(ALL(visx), false);
            fill(ALL(visy), false);
            fill(ALL(slack), inf);
            bfs(i);
        }
        for (int i = 1; i <= n; ++i)
        {
            if (edge[i][pa[i]] > 0)
            {
                res += edge[i][pa[i]];
            }
            else
            {
                pa[i] = 0;
            }
        }
        printf("%lld\n", res);
        for (int i = 1; i <= _m; ++i)
        {
            printf("%d ", pb[i]);
        }
        printf("\n");
    }
};
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    KM km = KM(n, n);
    for (int i = 1; i <= m; ++i)
    {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        km.add(u, v, w);
    }
    km.solve();
    // system("pause");
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
  </entry>
  <entry>
    <title>写在前面</title>
    <url>/2020/072355009.html</url>
    <content><![CDATA[<p>昨天被学弟问到怎么好久不更hexo的博客了, 我一时语塞, 只能回可能是太忙了吧..(其实就是懒</p>
<p>本来想着就在博客园凑合写一写, 可谁让我偏偏又是个偏执怪</p>
<p>博客园优化弄了一下午是在弄不下去了, 这突然想起来自己以前写的工程目录, 何止是丑陋,简直是丑陋…</p>
<p>好吧, 干脆全部推到重来算求, 重新拾起hexo</p>
<p>熬夜一天半算是整理出大概的样子, 也不知道还会不会更新, 看心情吧~~</p>
<blockquote>
<p>已更新</p>
<ul>
<li>avatar logo</li>
<li>首页轮播图 按天换==</li>
<li>首页隐藏音乐播放器</li>
<li>点击特效</li>
<li>MathJax</li>
<li>文章置顶和打赏</li>
<li>友链页面</li>
<li>留言面板</li>
<li>关于我页面</li>
<li>busuanzi统计</li>
<li>Gitalk评论</li>
<li>页脚</li>
<li>链接URL优化</li>
<li>时间线归档</li>
<li>底部标志更新</li>
<li>音乐歌单更新</li>
</ul>
</blockquote>
<p>因为换了主题, 以前的markdown格式不兼容, 所以文章都被我下了, 不知道会不会再传 0.0</p>
]]></content>
  </entry>
</search>
