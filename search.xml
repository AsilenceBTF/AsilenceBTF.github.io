<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/2020/072355009.html</url>
    <content><![CDATA[<p>昨天被学弟问到怎么好久不更hexo的博客了, 我一时语塞, 只能回可能是太忙了吧..(其实就是懒</p>
<p>本来想着就在博客园凑合写一写, 可谁让我偏偏又是个偏执怪</p>
<p>博客园优化弄了一下午是在弄不下去了, 这突然想起来自己以前写的工程目录, 何止是丑陋,简直是丑陋…</p>
<p>好吧, 干脆全部推到重来算求, 重新拾起hexo</p>
<p>熬夜一天半算是整理出大概的样子, 也不知道还会不会更新, 看心情吧~~</p>
<blockquote>
<p>已更新</p>
<ul>
<li>avatar logo</li>
<li>首页轮播图 按天换==</li>
<li>首页隐藏音乐播放器</li>
<li>点击特效</li>
<li>MathJax</li>
<li>文章置顶和打赏</li>
<li>友链页面</li>
<li>留言面板</li>
<li>关于我页面</li>
<li>busuanzi统计</li>
<li>Gitalk评论</li>
<li>页脚</li>
<li>链接URL优化</li>
<li>时间线归档</li>
<li>底部标志更新</li>
<li>音乐歌单更新</li>
<li>CDN加速</li>
</ul>
</blockquote>
<p>因为换了主题, 以前的markdown格式不兼容, 所以文章都被我下了, 不知道会不会再传 0.0</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Codeforces-659-div2</title>
    <url>/2020/072559060.html</url>
    <content><![CDATA[<h4 id="A-Common-Prefixes"><a href="#A-Common-Prefixes" class="headerlink" title="A  Common Prefixes"></a>A  Common Prefixes</h4><p>懒得想就暴力两层</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 1e5 + 105;
int a[150];
void solve(){
    int n; cin >> n;
    for(int i = 1; i <= n; ++i) cin >> a[i];
    string s = string(150, 'a');
    cout << s << endl;
    for(int i = 1; i <= n; ++i){
        for(int j = 0; j < a[i]; ++j){
            cout << s[j];
        }
        for(int j = a[i]; j < 150; ++j){
            s[j]++;
            if(s[j] > 'z') s[j] = 'a';
            cout << s[j];
        }cout << endl;
    }
}
int main(){
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="B1-Koa-and-the-Beach-Easy-Version"><a href="#B1-Koa-and-the-Beach-Easy-Version" class="headerlink" title="B1  Koa and the Beach (Easy Version)"></a>B1  Koa and the Beach (Easy Version)</h4><p><img src="https://i.loli.net/2020/07/25/9KN4cCmMLSr28Wd.png" alt="tem3.png"></p>
<p>万万没想到, $O(n*n*k*t)$的dp还真就是$1e9$  (狗头)</p>
<p>对着时间线和位置暴力dp, 注意自己所在的位置也是可以转移的</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 10050;
int d[150], n, l, k, t[300];
bool dp[105][N << 1];
void solve(){
    cin >> n >> k >> l;
    for(int i = 1; i <= n; ++i)
        cin >> d[i];
    for(int i = 0; i < k + k; ++i){
        t[i] = i;
        if(i > k) t[i] = k - (i - k);
    }
    for(int j = 0; j <= 2*n*k + 1; ++j){
        for(int i = 1; i <= n; ++i){
            dp[i][j] = false;
            dp[0][j] = true;
        }
        dp[n + 1][j] = false;
    }
    d[n + 1] = -3000;
    bool flag = false;
    for(int i = 1; i <= n; ++i){
        for(int j = 0; j <= 2*n*k; ++j){
            if(dp[i - 1][j] && d[i] + t[(j + 1)%(k + k)] <= l){
                dp[i][j + 1] = true;
            }else if(dp[i][j] && d[i] + t[(j + 1)%(k + k)] <= l){
                dp[i][j + 1] = true;
            }
            if(dp[n][j + 1]) flag = true;
        }
    }
    if(flag){
        cout << "YES" << endl;
    }else{
        cout << "NO" << endl;
    }
}
int main(){
    ios::sync_with_stdio(0),  cin.tie(0);
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="C-String-Transformation-1"><a href="#C-String-Transformation-1" class="headerlink" title="C  String Transformation 1"></a>C  String Transformation 1</h4><p>题意读的爆炸, 球球了, 别再出阅读理解了</p>
<blockquote>
<p>每次选任意个一样的字母x, 全部替换成y (y &gt; x)</p>
</blockquote>
<p>最后能否将$A \Rightarrow  B$</p>
<p>因为是从小到大变, 出现$ ai &gt; bi$ 就-1好了</p>
<p>记录一下每个字母的所有目标字母</p>
<p>从小到大枚举贪心,  如果没有出现已经改变过的(当前字母), 就直接改变到目标字母, ++ans</p>
<p>否则, 就加到已经改变的字母上, 攒到一起最后更改</p>
<p>样例把人误导了  :no_mouth:  </p>
<pre class="line-numbers language-c++"><code class="language-c++">#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 1e5 + 105;
void solve(){
    set<int>se[28];
    for(int i = 0; i < 26; ++i) se[i].clear();
    int n;
    cin >> n;
    string a, b;
    cin >> a >> b;
    for(int i = 0; i < n; ++i){
        if(a[i] > b[i]){
            cout << -1 << endl; return;
        }
        if(a[i] == b[i]) continue;
        se[a[i] - 'a'].insert(b[i] - 'a');
    }
    ll ans = 0;
    for(int i = 0; i < 26; ++i){
        int vis[26] = {0};
        for(auto it : se[i]){
            int flag = 0;
            for(int k = i + 1; k < it; ++k){
                if(vis[k]){
                    se[k].insert(it);
                    flag = 1; break;
                }
            }
            if(flag) continue;
            vis[it] = 1;
            ans ++;
        }
    }
    cout << ans << endl;
}   
int main(){
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="D-GameGame"><a href="#D-GameGame" class="headerlink" title="D  GameGame"></a>D  GameGame</h4><p>学弟给了波思路, 还是没切出来, wtcl  :sob: </p>
<p>很容易想到只要枚举最高位的情况就行</p>
<p>但是这里的最高位不是实际最高位, 而是有效最高位</p>
<blockquote>
<p>例如 2 2 1 1 1</p>
</blockquote>
<p>这里的最高位就不是2贡献的, 因为2最高位个数是偶数, 最后一定会抵消</p>
<p>那么最高位个数一定是奇数</p>
<p>注意 游戏是你先手, 所以最终你拿到的数字个数一定是$ \lceil n / 2 \rceil $</p>
<p>利用这个特点我们需要让对手拿到偶数个最高位</p>
<p>那么必输的情况只有一种$one%4 == 3 \bigwedge  zero%2 == 0$</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

void solve(){
    int n; cin >> n;
    vector<int> a(n + 1);
    int d = 0;
    for(int i = 1; i <= n; ++i){
        cin >> a[i];
        d ^= a[i];
    }
    if(d == 0){
        cout << "DRAW" << endl; return;
    }
    for(int i = 31; i >= 0; --i){
        if(d >> i & 1){
            int one = 0, zero = 0;
            for(int j = 1; j <= n; ++j){
                if(a[j] >> i & 1) ++one;
                else ++zero;
            }
            if(one % 4 == 3 && zero % 2 == 0){
                cout << "LOSE" << endl;
            }else{
                cout << "WIN" << endl;
            }
            break;
        }
    }
}
int main(){
    ios::sync_with_stdio(0),  cin.tie(0);
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>枚举</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 658(div2)</title>
    <url>/2020/07231255.html</url>
    <content><![CDATA[<h4 id="A-Common-Subsequence"><a href="#A-Common-Subsequence" class="headerlink" title="A  Common Subsequence"></a>A  Common Subsequence</h4><p>签到</p>
<pre class="line-numbers language-c++"><code class="language-c++">
#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 5e5 + 105;

void solve(){
    int n, m;
    cin >> n >> m;
    set<int>se;
    for(int i = 1; i <= n; ++i){
        int x; cin >> x;
        se.insert(x);
    }
    int k = 0, flag = 0;
    for(int i = 1; i <= m; ++i){
        int x;
        cin >> x;
        if(se.count(x) > 0){
            k = 1; flag = x;
        }
    }
    if(k){
        cout << "YES" << endl;
        cout << k << " " << flag << endl;
    }else{
        cout << "NO" << endl;
    }
}
int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="B-Sequential-Nim"><a href="#B-Sequential-Nim" class="headerlink" title="B  Sequential Nim"></a>B  Sequential Nim</h4><blockquote>
<p>结论: 首先碰到 &gt; 1 的数的人胜利</p>
</blockquote>
<p>证明的话只要分三种情况</p>
<blockquote>
<ol>
<li><p>序列为3 3 3 3</p>
<p>轮流拿 2 1 2 1 2 1 3</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><p>序列为3 1 3 3</p>
<p>轮流拿 3 1 2 1 3</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><p>序列为 3 1 1 3</p>
<p>轮流拿 2 1 1 1 3</p>
</li>
</ol>
</blockquote>
<p>以上三种序列足以覆盖所有情况</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 1e5 + 105;
int a[N];
void solve(){
    int n;
    cin >> n;
    int one = 0, idx = 0;
    for(int i = 1; i <= n; ++i){
        cin >> a[i];
        if(a[i] == 1) one++;
        else{
            if(idx == 0) idx = i;
        }
    }
    if(one == 0){
        cout << "First" << endl; return;
    }else if(one == n){
        if(n&1) cout << "First" << endl;
        else cout << "Second" << endl;
    }else{
        if(idx&1) cout << "First" << endl;
        else cout << "Second" << endl;
    }

}
int main(){c++
    cin.tie(0);
    ios::sync_with_stdio(0);
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="C-Prefix-Flip"><a href="#C-Prefix-Flip" class="headerlink" title="C  Prefix Flip"></a>C  Prefix Flip</h4><p>若串首字符不等于目标字符, 则直接翻转</p>
<p>若串首字符等于目标字符, 则先翻转串首, 在翻转</p>
<p>这样构造一定小于$2n$</p>
<p>双指针记录一下串首和串尾的位置和翻转情况即可</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 1e5 + 105;
void solve(){
    int n, l, r, f = 0; cin >> n;
    string s, t;
    cin >> s >> t;
    if(s == t){
        cout << 0 << endl; return;
    }
    l = 0, r = n - 1;
    vector<int> ans;
    for(int i = n - 1; i >= 0; --i){
        if((s[l] == t[i] && f%2 == 0) || (s[l] != t[i] && f%2 == 1)){
            ans.push_back(1);
        }
        ans.push_back(i + 1);
        f++;
        swap(l, r);
        if(f&1) ++r;
        else --r;
    }
    cout << sz(ans) << " ";
    for(auto it : ans) cout << it << " ";
    cout << endl;
}
int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    int _ = 1;
    cin >> _;
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="D-Unmerge"><a href="#D-Unmerge" class="headerlink" title="D  Unmerge"></a>D  Unmerge</h4><p>01背包变形</p>
<p>观察发现, 两个前缀最大之间的数是可以连续的存在一个序列里的</p>
<p>预处理出所有这样的段</p>
<p>dp一下能不能组成长度为n的序列即可</p>
<pre class="line-numbers language-c++"><code class="language-c++">
#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
typedef long long ll;

const int N = 4050;
int a[N], pre[N], preidx[N], dp[N];
void solve(){
    int n; cin >> n;
    int m = n + n;
    for(int i = 1; i <= m; ++i){
        cin >> a[i];
        pre[i] = a[i];
        preidx[i] = i;
        if(pre[i - 1] > pre[i]){
            pre[i] = pre[i - 1];
            preidx[i] = preidx[i - 1];
        } dp[i] = 0;
    }
    vector<int> v;
    for(int i = 2; i <= m; ++i){
        if(preidx[i] == i){
            v.push_back(preidx[i] - preidx[i - 1]); 
        }
    }
    for(auto it : v){
        for(int j = n; j >= it; --j){
            dp[j] = max(dp[j], dp[j - it] + it);
        }
    }
    if(dp[n] == n) cout << "YES" << endl;
    else cout << "NO" << endl;
}
int main(){
    int  _ = 1;
    cin >> _;c++
    for(int i = 1; i <= _; ++i) solve();
    // system("pause");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>dream deverse</title>
    <url>/2020/072338086.html</url>
    <content><![CDATA[<blockquote>
<p>这是一个测试页面</p>
</blockquote>
<pre class="line-numbers language-c++"><code class="language-c++">
#define sz(x) int(x.size())
#define ALL(x) x.begin(), x.end()
#define lowbit(x) ((x) & (-x))
#define INF 0x3f3f3f3f
#define LNF 0x3f3f3f3f3f3f3f3f
#define DOF 0x7f7f7f7f
typedef long long ll;
const int N = 2e5 + 105;
struct KM
{
    vector<vector<ll>> edge;
    vector<int> pa;
    vector<int> pb;
    vector<bool> visx;
    vector<bool> visy;
    vector<int> pre;
    vector<ll> lx;
    vector<ll> ly;
    vector<ll> slack;
    ll res = 0, inf;
    int n, _n, _m;
    queue<int> que;
    KM(int __n, int __m) : _n(__n), _m(__m)
    {
        res = 0;
        inf = LNF;
        n = max(_n, _m);
        edge = vector<vector<ll>>(n + 1, vector<ll>(n + 1));
        pa = vector<int>(n + 1);
        pb = vector<int>(n + 1);
        visx = vector<bool>(n + 1);
        visy = vector<bool>(n + 1);
        pre = vector<int>(n + 1);
        lx = vector<ll>(n + 1, -inf);
        ly = vector<ll>(n + 1);
        slack = vector<ll>(n + 1);
    }
    void add(int u, int v, ll w)
    {
        edge[u][v] = max(0ll, w);
    }
    bool check(int v)
    {
        visy[v] = true;
        if (pb[v])
        {
            que.push(pb[v]);
            visx[pb[v]] = true;
            return false;
        }
        while (v)
        {
            pb[v] = pre[v];
            swap(v, pa[pre[v]]);
        }
        return true;
    }
    void bfs(int u)
    {
        while (!que.empty())
            que.pop();
        visx[u] = true;
        que.push(u);
        while (true)
        {
            while (!que.empty())
            {
                u = que.front();
                que.pop();
                for (int v = 1; v <= n; ++v)
                {
                    if (!visy[v])
                    {
                        ll delta = lx[u] + ly[v] - edge[u][v];
                        if (slack[v] >= delta)
                        {
                            pre[v] = u;
                            if (delta)
                            {
                                slack[v] = delta;
                            }
                            else if (check(v))
                            {
                                return;
                            }
                        }
                    }
                }
            }
            ll a = inf;
            for (int i = 1; i <= n; ++i)
            {
                if (!visy[i])
                {
                    a = min(a, slack[i]);
                }
            }
            for (int i = 1; i <= n; ++i)
            {
                if (visx[i])
                {
                    lx[i] -= a;
                }
                if (visy[i])
                {
                    ly[i] += a;
                }
                else
                {
                    slack[i] -= a;
                }
            }
            for (int i = 1; i <= n; ++i)
            {
                if (!visy[i] && slack[i] == 0 && check(i))
                {
                    return;
                }
            }
        }
    }
    void solve()
    {
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                lx[i] = max(lx[i], edge[i][j]);
            }
        }
        // for(int i = 1; i <= n; ++i) cout << lx[i] << " ";
        for (int i = 1; i <= n; ++i)
        {
            fill(ALL(visx), false);
            fill(ALL(visy), false);
            fill(ALL(slack), inf);
            bfs(i);
        }
        for (int i = 1; i <= n; ++i)
        {
            if (edge[i][pa[i]] > 0)
            {
                res += edge[i][pa[i]];
            }
            else
            {
                pa[i] = 0;
            }
        }
        printf("%lld\n", res);
        for (int i = 1; i <= _m; ++i)
        {
            printf("%d ", pb[i]);
        }
        printf("\n");
    }
};
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    KM km = KM(n, n);
    for (int i = 1; i <= m; ++i)
    {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        km.add(u, v, w);
    }
    km.solve();
    // system("pause");
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
</search>
